// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// This is a stub implementation for gRPC service

package proto

import (
	"context"

	"google.golang.org/grpc"
)

// MiningPoolClient is the client API for MiningPool service.
type MiningPoolClient interface {
	RegisterMiner(ctx context.Context, in *MinerInfo, opts ...grpc.CallOption) (*RegistrationResponse, error)
	GetWork(ctx context.Context, in *WorkRequest, opts ...grpc.CallOption) (*WorkResponse, error)
	SubmitWork(ctx context.Context, in *WorkSubmission, opts ...grpc.CallOption) (*SubmissionResponse, error)
	Heartbeat(ctx context.Context, in *MinerStatus, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	StopMining(ctx context.Context, in *MinerInfo, opts ...grpc.CallOption) (*StopResponse, error)
}

type miningPoolClient struct {
	cc grpc.ClientConnInterface
}

func NewMiningPoolClient(cc grpc.ClientConnInterface) MiningPoolClient {
	return &miningPoolClient{cc}
}

func (c *miningPoolClient) RegisterMiner(ctx context.Context, in *MinerInfo, opts ...grpc.CallOption) (*RegistrationResponse, error) {
	out := new(RegistrationResponse)
	err := c.cc.Invoke(ctx, "/mining.MiningPool/RegisterMiner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *miningPoolClient) GetWork(ctx context.Context, in *WorkRequest, opts ...grpc.CallOption) (*WorkResponse, error) {
	out := new(WorkResponse)
	err := c.cc.Invoke(ctx, "/mining.MiningPool/GetWork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *miningPoolClient) SubmitWork(ctx context.Context, in *WorkSubmission, opts ...grpc.CallOption) (*SubmissionResponse, error) {
	out := new(SubmissionResponse)
	err := c.cc.Invoke(ctx, "/mining.MiningPool/SubmitWork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *miningPoolClient) Heartbeat(ctx context.Context, in *MinerStatus, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, "/mining.MiningPool/Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *miningPoolClient) StopMining(ctx context.Context, in *MinerInfo, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, "/mining.MiningPool/StopMining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MiningPoolServer is the server API for MiningPool service.
type MiningPoolServer interface {
	RegisterMiner(context.Context, *MinerInfo) (*RegistrationResponse, error)
	GetWork(context.Context, *WorkRequest) (*WorkResponse, error)
	SubmitWork(context.Context, *WorkSubmission) (*SubmissionResponse, error)
	Heartbeat(context.Context, *MinerStatus) (*HeartbeatResponse, error)
	StopMining(context.Context, *MinerInfo) (*StopResponse, error)
}

// UnimplementedMiningPoolServer must be embedded to have forward compatible implementations.
type UnimplementedMiningPoolServer struct {
}

func (UnimplementedMiningPoolServer) RegisterMiner(context.Context, *MinerInfo) (*RegistrationResponse, error) {
	return nil, nil
}

func (UnimplementedMiningPoolServer) GetWork(context.Context, *WorkRequest) (*WorkResponse, error) {
	return nil, nil
}

func (UnimplementedMiningPoolServer) SubmitWork(context.Context, *WorkSubmission) (*SubmissionResponse, error) {
	return nil, nil
}

func (UnimplementedMiningPoolServer) Heartbeat(context.Context, *MinerStatus) (*HeartbeatResponse, error) {
	return nil, nil
}

func (UnimplementedMiningPoolServer) StopMining(context.Context, *MinerInfo) (*StopResponse, error) {
	return nil, nil
}

// UnsafeMiningPoolServer may be embedded to opt out of forward compatibility for this service.
type UnsafeMiningPoolServer interface {
	mustEmbedUnimplementedMiningPoolServer()
}

func RegisterMiningPoolServer(s grpc.ServiceRegistrar, srv MiningPoolServer) {
	s.RegisterService(&MiningPool_ServiceDesc, srv)
}

var MiningPool_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mining.MiningPool",
	HandlerType: (*MiningPoolServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterMiner",
			Handler:    _MiningPool_RegisterMiner_Handler,
		},
		{
			MethodName: "GetWork",
			Handler:    _MiningPool_GetWork_Handler,
		},
		{
			MethodName: "SubmitWork",
			Handler:    _MiningPool_SubmitWork_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _MiningPool_Heartbeat_Handler,
		},
		{
			MethodName: "StopMining",
			Handler:    _MiningPool_StopMining_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mining.proto",
}

func _MiningPool_RegisterMiner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MiningPoolServer).RegisterMiner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mining.MiningPool/RegisterMiner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MiningPoolServer).RegisterMiner(ctx, req.(*MinerInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MiningPool_GetWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MiningPoolServer).GetWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mining.MiningPool/GetWork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MiningPoolServer).GetWork(ctx, req.(*WorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MiningPool_SubmitWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkSubmission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MiningPoolServer).SubmitWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mining.MiningPool/SubmitWork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MiningPoolServer).SubmitWork(ctx, req.(*WorkSubmission))
	}
	return interceptor(ctx, in, info, handler)
}

func _MiningPool_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MiningPoolServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mining.MiningPool/Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MiningPoolServer).Heartbeat(ctx, req.(*MinerStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MiningPool_StopMining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MiningPoolServer).StopMining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mining.MiningPool/StopMining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MiningPoolServer).StopMining(ctx, req.(*MinerInfo))
	}
	return interceptor(ctx, in, info, handler)
}

// NOTE: In production, this file would be generated by:
// protoc --go-grpc_out=. --go-grpc_opt=paths=source_relative proto/mining.proto
