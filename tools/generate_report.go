// Package main implements a mining pool activity report generator.
//
// This tool analyzes pool log files generated by the RedTeamCoin server
// and produces detailed Markdown reports showing miner activity, resource
// usage, and impact analysis over specified time periods.
//
// Usage:
//
//	generate_report -log pool_log.json -start 2025-01-01 -end 2025-01-31
//
// The tool calculates estimated CPU hours, power consumption, and costs
// based on miner activity and provides a comprehensive overview of pool
// operations.
package main

import (
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"text/template"
	"time"
)

//go:embed templates/report_template.tmpl
var reportTemplate string

// LogEntry represents a single event logged by the mining pool server.
// Events include miner registration, blocks mined, and control actions.
type LogEntry struct {
	Timestamp time.Time              `json:"timestamp"`
	EventType string                 `json:"event_type"`
	MinerID   string                 `json:"miner_id,omitempty"`
	Details   map[string]interface{} `json:"details,omitempty"`
	Message   string                 `json:"message"`
}

// MinerLogInfo represents miner information in the log
type MinerLogInfo struct {
	ID                 string    `json:"id"`
	IPAddress          string    `json:"ip_address"`
	IPAddressActual    string    `json:"ip_address_actual"`
	Hostname           string    `json:"hostname"`
	RegisteredAt       time.Time `json:"registered_at"`
	LastHeartbeat      time.Time `json:"last_heartbeat"`
	Active             bool      `json:"active"`
	ShouldMine         bool      `json:"should_mine"`
	CPUThrottlePercent int       `json:"cpu_throttle_percent"`
	BlocksMined        int64     `json:"blocks_mined"`
	HashRate           int64     `json:"hash_rate"`
	CPUUsagePercent    float64   `json:"cpu_usage_percent"`
	TotalHashes        int64     `json:"total_hashes"`
	TotalMiningTime    float64   `json:"total_mining_time_seconds"`
	GPUEnabled         bool      `json:"gpu_enabled"`
	GPUHashRate        int64     `json:"gpu_hash_rate,omitempty"`
	HybridMode         bool      `json:"hybrid_mode"`
}

// PoolSnapshot represents a snapshot of the pool state
type PoolSnapshot struct {
	Timestamp        time.Time      `json:"timestamp"`
	TotalMiners      int            `json:"total_miners"`
	ActiveMiners     int            `json:"active_miners"`
	TotalHashRate    int64          `json:"total_hash_rate"`
	TotalBlocksMined int64          `json:"total_blocks_mined"`
	BlockchainHeight int64          `json:"blockchain_height"`
	Difficulty       int            `json:"difficulty"`
	Miners           []MinerLogInfo `json:"miners"`
}

// LogFile represents the complete log file structure
type LogFile struct {
	ServerStartTime time.Time    `json:"server_start_time"`
	ServerUptime    float64      `json:"server_uptime_seconds"`
	LastUpdate      time.Time    `json:"last_update"`
	Events          []LogEntry   `json:"events"`
	CurrentSnapshot PoolSnapshot `json:"current_snapshot"`
}

// MinerImpactStats contains calculated impact metrics for a single miner
// over a reporting period. This includes resource usage estimates and cost
// projections based on industry-standard power consumption models.
type MinerImpactStats struct {
	MinerID           string
	Hostname          string
	IPAddress         string
	IPAddressActual   string
	FirstSeen         time.Time
	LastSeen          time.Time
	TotalMiningTime   time.Duration
	TotalHashes       int64
	BlocksMined       int64
	AvgCPUUsage       float64
	PeakCPUUsage      float64
	GPUEnabled        bool
	HybridMode        bool
	EstimatedCPUHours float64
	EstimatedKWh      float64
	EstimatedCost     float64
	ComputeImpact     string
	MiningType        string
}

// SystemImpactReport represents the overall impact report
type SystemImpactReport struct {
	ReportGeneratedAt time.Time
	AnalysisPeriod    string
	StartDate         time.Time
	EndDate           time.Time
	TotalMiners       int
	UniqueHosts       int
	UniqueIPs         int

	// Resource Consumption
	TotalMiningHours   float64
	TotalHashes        int64
	TotalBlocksMined   int64
	TotalEstimatedKWh  float64
	TotalEstimatedCost float64
	AvgSystemCPUUsage  float64
	PeakSystemCPUUsage float64

	// Performance Impact
	MinersWithHighCPU int // >80% CPU usage
	MinersWithGPU     int
	MinersWithHybrid  int

	// Individual Miner Stats
	MinerStats []MinerImpactStats
}

const (
	// Cost assumptions
	avgCPUPowerWatts   = 150.0 // Average CPU power consumption under load
	avgGPUPowerWatts   = 250.0 // Average GPU power consumption under load
	electricityCostPer = 0.12  // $ per kWh (adjust for your region)

	// Performance thresholds
	highCPUThreshold = 80.0
)

func main() {
	logFile := flag.String("log", "pool_log.json", "Path to the pool log file")
	flag.Parse()

	if *logFile == "" {
		fmt.Println("Usage: generate_report -log <path_to_log_file>")
		os.Exit(1)
	}

	// Clean the path and validate it exists as a regular file
	cleanPath := filepath.Clean(*logFile)
	info, err := os.Stat(cleanPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error accessing log file: %v\n", err)
		os.Exit(1)
	}
	if info.IsDir() {
		fmt.Fprintf(os.Stderr, "Error: %s is a directory, not a file\n", cleanPath)
		os.Exit(1)
	}

	// Read and parse log file
	data, err := os.ReadFile(cleanPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading log file: %v\n", err)
		os.Exit(1)
	}

	var logData LogFile
	if err := json.Unmarshal(data, &logData); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing log file: %v\n", err)
		os.Exit(1)
	}

	// Generate impact report
	report := analyzeImpact(&logData)

	// Generate markdown report
	reportFile := generateReportFilename(report.StartDate, report.EndDate)
	if err := writeMarkdownReport(reportFile, &report); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing report: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Report generated successfully: %s\n", reportFile)
}

// analyzeImpact processes log data to generate a comprehensive system impact
// report. It calculates resource consumption, identifies unique systems,
// processes miner statistics, and generates per-miner impact metrics including
// estimated costs and hardware degradation.
func analyzeImpact(logData *LogFile) SystemImpactReport {
	report := SystemImpactReport{
		ReportGeneratedAt: time.Now(),
		StartDate:         logData.ServerStartTime,
		EndDate:           logData.LastUpdate,
		MinerStats:        make([]MinerImpactStats, 0),
	}

	// Calculate analysis period
	duration := report.EndDate.Sub(report.StartDate)
	report.AnalysisPeriod = formatDuration(duration)

	// Track unique hosts and IPs
	uniqueHosts := make(map[string]bool)
	uniqueIPs := make(map[string]bool)

	// Collect miners from events and snapshots
	minerMap := collectMinersFromEvents(logData.Events)
	processSnapshotData(logData.CurrentSnapshot.Miners, minerMap, uniqueHosts, uniqueIPs, &report)

	// Calculate averages
	finalizeReport(&report, minerMap, uniqueHosts, uniqueIPs)

	return report
}

func collectMinersFromEvents(events []LogEntry) map[string]*MinerImpactStats {
	minerMap := make(map[string]*MinerImpactStats)

	for _, event := range events {
		if event.MinerID == "" {
			continue
		}

		if _, exists := minerMap[event.MinerID]; !exists {
			minerMap[event.MinerID] = &MinerImpactStats{
				MinerID:   event.MinerID,
				FirstSeen: event.Timestamp,
				LastSeen:  event.Timestamp,
			}
		} else {
			if event.Timestamp.After(minerMap[event.MinerID].LastSeen) {
				minerMap[event.MinerID].LastSeen = event.Timestamp
			}
			if event.Timestamp.Before(minerMap[event.MinerID].FirstSeen) {
				minerMap[event.MinerID].FirstSeen = event.Timestamp
			}
		}
	}

	return minerMap
}

func processSnapshotData(miners []MinerLogInfo, minerMap map[string]*MinerImpactStats,
	uniqueHosts, uniqueIPs map[string]bool, report *SystemImpactReport) {

	for _, miner := range miners {
		stats := getOrCreateMinerStats(miner, minerMap)
		updateMinerStats(stats, miner)
		updateUniqueTracking(miner, uniqueHosts, uniqueIPs)
		updateReportTotals(report, stats, miner)
		report.MinerStats = append(report.MinerStats, *stats)
	}
}

func getOrCreateMinerStats(miner MinerLogInfo, minerMap map[string]*MinerImpactStats) *MinerImpactStats {
	stats, exists := minerMap[miner.ID]
	if !exists {
		stats = &MinerImpactStats{
			MinerID:   miner.ID,
			FirstSeen: miner.RegisteredAt,
			LastSeen:  miner.LastHeartbeat,
		}
		minerMap[miner.ID] = stats
	}
	return stats
}

func updateMinerStats(stats *MinerImpactStats, miner MinerLogInfo) {
	stats.Hostname = miner.Hostname
	stats.IPAddress = miner.IPAddress
	stats.IPAddressActual = miner.IPAddressActual
	stats.TotalMiningTime = time.Duration(miner.TotalMiningTime * float64(time.Second))
	stats.TotalHashes = miner.TotalHashes
	stats.BlocksMined = miner.BlocksMined
	stats.AvgCPUUsage = miner.CPUUsagePercent
	stats.PeakCPUUsage = miner.CPUUsagePercent
	stats.GPUEnabled = miner.GPUEnabled
	stats.HybridMode = miner.HybridMode

	// Determine mining type
	stats.MiningType = determineMiningType(miner.GPUEnabled, miner.HybridMode)

	// Calculate power consumption
	cpuHours := stats.TotalMiningTime.Hours()
	stats.EstimatedCPUHours = cpuHours

	powerWatts := calculatePowerWatts(miner)
	stats.EstimatedKWh = (powerWatts * cpuHours) / 1000.0
	stats.EstimatedCost = stats.EstimatedKWh * electricityCostPer

	// Compute impact assessment
	stats.ComputeImpact = getComputeImpact(stats.AvgCPUUsage)
}

func determineMiningType(gpuEnabled, hybridMode bool) string {
	switch {
	case gpuEnabled && hybridMode:
		return "CPU+GPU Hybrid"
	case gpuEnabled:
		return "GPU Only"
	default:
		return "CPU Only"
	}
}

func calculatePowerWatts(miner MinerLogInfo) float64 {
	var powerWatts float64
	switch {
	case miner.HybridMode:
		powerWatts = avgCPUPowerWatts + avgGPUPowerWatts
	case miner.GPUEnabled:
		powerWatts = avgGPUPowerWatts
	default:
		powerWatts = avgCPUPowerWatts
	}

	// Adjust for CPU usage percentage
	if !miner.GPUEnabled {
		powerWatts *= (miner.CPUUsagePercent / 100.0)
	}

	return powerWatts
}

func getComputeImpact(cpuUsage float64) string {
	switch {
	case cpuUsage >= 90:
		return "CRITICAL - System severely degraded"
	case cpuUsage >= 70:
		return "HIGH - Significant performance impact"
	case cpuUsage >= 50:
		return "MODERATE - Noticeable slowdowns"
	default:
		return "LOW - Minor impact"
	}
}

func updateUniqueTracking(miner MinerLogInfo, uniqueHosts, uniqueIPs map[string]bool) {
	uniqueHosts[miner.Hostname] = true
	if miner.IPAddress != "" {
		uniqueIPs[miner.IPAddress] = true
	}
	if miner.IPAddressActual != "" && miner.IPAddressActual != miner.IPAddress {
		uniqueIPs[miner.IPAddressActual] = true
	}
}

func updateReportTotals(report *SystemImpactReport, stats *MinerImpactStats, miner MinerLogInfo) {
	cpuHours := stats.TotalMiningTime.Hours()
	report.TotalMiningHours += cpuHours
	report.TotalHashes += miner.TotalHashes
	report.TotalBlocksMined += miner.BlocksMined
	report.TotalEstimatedKWh += stats.EstimatedKWh
	report.TotalEstimatedCost += stats.EstimatedCost

	if miner.CPUUsagePercent >= highCPUThreshold {
		report.MinersWithHighCPU++
	}
	if miner.GPUEnabled {
		report.MinersWithGPU++
	}
	if miner.HybridMode {
		report.MinersWithHybrid++
	}
}

func finalizeReport(report *SystemImpactReport, minerMap map[string]*MinerImpactStats,
	uniqueHosts, uniqueIPs map[string]bool) {

	report.TotalMiners = len(report.MinerStats)
	report.UniqueHosts = len(uniqueHosts)
	report.UniqueIPs = len(uniqueIPs)

	if report.TotalMiners > 0 {
		totalCPU := 0.0
		maxCPU := 0.0
		for _, stats := range report.MinerStats {
			totalCPU += stats.AvgCPUUsage
			if stats.PeakCPUUsage > maxCPU {
				maxCPU = stats.PeakCPUUsage
			}
		}
		report.AvgSystemCPUUsage = totalCPU / float64(report.TotalMiners)
		report.PeakSystemCPUUsage = maxCPU
	}

	// Sort miners by impact (total cost descending)
	sort.Slice(report.MinerStats, func(i, j int) bool {
		return report.MinerStats[i].EstimatedCost > report.MinerStats[j].EstimatedCost
	})
}

// generateReportFilename creates a descriptive filename for the impact report
// based on the analysis date range in the format
// "Report_Miner_Activity_from_YYYY-MM-DD_to_YYYY-MM-DD.md".
func generateReportFilename(startDate, endDate time.Time) string {
	startStr := startDate.Format("2006-01-02")
	endStr := endDate.Format("2006-01-02")
	return fmt.Sprintf("Report_Miner_Activity_from_%s_to_%s.md", startStr, endStr)
}

// categorizeImpact categorizes miners by CPU usage impact level and returns counts.
func categorizeImpact(miners []MinerImpactStats) (critical, high, moderate, low int) {
	for _, stats := range miners {
		switch {
		case stats.AvgCPUUsage >= 90:
			critical++
		case stats.AvgCPUUsage >= 70:
			high++
		case stats.AvgCPUUsage >= 50:
			moderate++
		default:
			low++
		}
	}
	return
}

// writeMarkdownReport generates a detailed Markdown-formatted impact
// assessment report and writes it to the specified file using Go templates.
func writeMarkdownReport(filename string, report *SystemImpactReport) error {
	// Validate that filename is a simple basename without path separators
	cleanName := filepath.Clean(filename)
	if cleanName == "." || cleanName == ".." || cleanName != filepath.Base(cleanName) {
		return fmt.Errorf("invalid report filename %q: must be a simple filename without path separators", filename)
	}

	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	root, err := os.OpenRoot(cwd)
	if err != nil {
		return fmt.Errorf("failed to open root directory: %w", err)
	}
	defer root.Close()

	f, err := root.Create(cleanName)
	if err != nil {
		return err
	}
	defer f.Close()

	// Categorize systems by impact
	critical, high, moderate, low := categorizeImpact(report.MinerStats)

	// Prepare template data
	data := struct {
		*SystemImpactReport
		Critical              int
		High                  int
		Moderate              int
		Low                   int
		CPUPowerWatts         float64
		GPUPowerWatts         float64
		ElectricityCostPer    float64
		HardwareReplacement   string
		IncidentResponse      string
		Maintenance           string
		HighCPUPercent        float64
		CPUOnlySystems        int
		GPUAcceleratedSystems int
		DailyAvgKWh           float64
		DailyAvgCost          float64
		Top10Count            int
		FormatNumber          func(int64) string
		FormatNumberShort     func(int64) string
		FormatDuration        func(time.Duration) string
		Truncate              func(string, int) string
		GetImpactLevel        func(float64) string
		FormatTime            func(time.Time) string
	}{
		SystemImpactReport:    report,
		Critical:              critical,
		High:                  high,
		Moderate:              moderate,
		Low:                   low,
		CPUPowerWatts:         avgCPUPowerWatts,
		GPUPowerWatts:         avgGPUPowerWatts,
		ElectricityCostPer:    electricityCostPer,
		HardwareReplacement:   estimateHardwareReplacement(report.TotalMiners),
		IncidentResponse:      estimateIncidentResponse(report.TotalMiners),
		Maintenance:           estimateMaintenance(report.TotalMiners),
		HighCPUPercent:        float64(report.MinersWithHighCPU) / float64(report.TotalMiners) * 100.0,
		CPUOnlySystems:        report.TotalMiners - report.MinersWithGPU,
		GPUAcceleratedSystems: report.MinersWithGPU - report.MinersWithHybrid,
		DailyAvgKWh:           report.TotalEstimatedKWh / (report.TotalMiningHours / 24.0),
		DailyAvgCost:          report.TotalEstimatedCost / (report.TotalMiningHours / 24.0),
		Top10Count:            min(10, len(report.MinerStats)),
		FormatNumber:          formatNumber,
		FormatNumberShort:     formatNumberShort,
		FormatDuration:        formatDuration,
		Truncate:              truncate,
		GetImpactLevel:        getImpactLevel,
		FormatTime:            func(t time.Time) string { return t.Format("2006-01-02 15:04:05") },
	}

	// Create template with custom functions
	funcMap := template.FuncMap{
		"add":   func(a, b int) int { return a + b },
		"divf":  func(a, b float64) float64 { return a / b },
		"slice": func(s []MinerImpactStats, start, end int) []MinerImpactStats { return s[start:end] },
	}

	tmpl, err := template.New("report").Funcs(funcMap).Parse(reportTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// formatDuration converts a time.Duration to a human-readable string in the
// format "Xd Xh Xm" (days, hours, minutes) or "Xh Xm" for durations less than
// a day.
func formatDuration(d time.Duration) string {
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60

	if hours > 24 {
		days := hours / 24
		hours %= 24
		return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
	}
	return fmt.Sprintf("%dh %dm", hours, minutes)
}

// formatNumber converts large integers to abbreviated string format with
// suffix (K for thousands, M for millions, B for billions, T for trillions)
// for improved readability in reports.
func formatNumber(n int64) string {
	switch {
	case n >= 1e12:
		return fmt.Sprintf("%.2fT", float64(n)/1e12)
	case n >= 1e9:
		return fmt.Sprintf("%.2fB", float64(n)/1e9)
	case n >= 1e6:
		return fmt.Sprintf("%.2fM", float64(n)/1e6)
	case n >= 1e3:
		return fmt.Sprintf("%.2fK", float64(n)/1e3)
	default:
		return fmt.Sprintf("%d", n)
	}
}

func formatNumberShort(n int64) string {
	switch {
	case n >= 1e12:
		return fmt.Sprintf("%.1fT", float64(n)/1e12)
	case n >= 1e9:
		return fmt.Sprintf("%.1fB", float64(n)/1e9)
	case n >= 1e6:
		return fmt.Sprintf("%.1fM", float64(n)/1e6)
	case n >= 1e3:
		return fmt.Sprintf("%.1fK", float64(n)/1e3)
	default:
		return fmt.Sprintf("%d", n)
	}
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// getImpactLevel categorizes system performance impact based on CPU usage
// percentage. Returns CRITICAL (â‰¥90%), HIGH (70-89%), MODERATE (50-69%),
// or LOW (<50%).
func getImpactLevel(cpuUsage float64) string {
	switch {
	case cpuUsage >= 90:
		return "CRITICAL"
	case cpuUsage >= 70:
		return "HIGH"
	case cpuUsage >= 50:
		return "MODERATE"
	default:
		return "LOW"
	}
}

func estimateHardwareReplacement(minerCount int) string {
	// Assume average workstation cost of $1000, 30% accelerated replacement
	cost := float64(minerCount) * 1000.0 * 0.30
	if cost >= 1e6 {
		return fmt.Sprintf("%.2fM", cost/1e6)
	} else if cost >= 1e3 {
		return fmt.Sprintf("%.2fK", cost/1e3)
	}
	return fmt.Sprintf("%.2f", cost)
}

func estimateIncidentResponse(minerCount int) string {
	// Base cost + per-system investigation
	baseCost := 5000.0     // Initial investigation
	perSystemCost := 200.0 // Per-system remediation
	cost := baseCost + (float64(minerCount) * perSystemCost)
	if cost >= 1e6 {
		return fmt.Sprintf("%.2fM", cost/1e6)
	} else if cost >= 1e3 {
		return fmt.Sprintf("%.2fK", cost/1e3)
	}
	return fmt.Sprintf("%.2f", cost)
}

func estimateMaintenance(minerCount int) string {
	// Estimated cost per system for thermal inspection and maintenance
	perSystemCost := 150.0
	cost := float64(minerCount) * perSystemCost
	if cost >= 1e6 {
		return fmt.Sprintf("%.2fM", cost/1e6)
	} else if cost >= 1e3 {
		return fmt.Sprintf("%.2fK", cost/1e3)
	}
	return fmt.Sprintf("%.2f", cost)
}
